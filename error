import { useCallback, useEffect, useState } from 'react'
import { useDispatch, useSelector } from 'react-redux'
import { 
  selectCurrentCall,
  setCurrentCall,
  initiateCall as initiateCallAction,
  answerCall as answerCallAction,
  endCall as endCallAction,
} from '@/src/store/slices/messageSlice'
import type { Call } from '@/src/types/message'
import type { User } from '@/src/types/users'
import { useWebRTC } from './useWebRTC'
import { useWebSocket } from '@/src/hooks/useWebSocket'
import { toast } from '@/src/components/ui/use-toast'

export const useCalls = (token: string | null) => {
  const dispatch = useDispatch()
  const { call: callWs } = useWebSocket(token)
  const currentCall = useSelector(selectCurrentCall)
  const [incomingCall, setIncomingCall] = useState<Call | null>(null)
  
  // WebRTC instance
  const webrtc = useWebRTC({
    onIceCandidate: (candidate) => {
      if (currentCall) {
        console.log('ðŸ§Š Sending ICE candidate:', candidate)
        callWs.sendIceCandidate(currentCall.id, candidate.toJSON())
      }
    },
    onConnectionStateChange: (state) => {
      console.log('ðŸ”Œ WebRTC connection state:', state)
      if (state === 'failed' || state === 'disconnected') {
        console.warn('âš ï¸ WebRTC connection failed/disconnected')
        if (currentCall) {
          hangUp(currentCall.id)
        }
      }
    }
  })
  
  // âœ… FIX: Listen for WebSocket call events with proper handling
  useEffect(() => {
    if (!callWs) return

    // Incoming call - show notification
    const unsubIncoming = callWs.on('call_initiated', async (data) => {
      console.log('ðŸ“ž Incoming call event:', data)
      
      // Create minimal user object
      const caller: User = {
        id: data.caller_id,
        username: data.caller_username,
        email: '',
        display_name: data.caller_username,
        email_verified: false,
        created_at: new Date().toISOString(),
        is_online: false,
        last_seen: null,
        profile: {
          id: `temp-profile-${data.caller_id}`,
          bio: '',
          avatar: null,
          phone: '',
          location: '',
          is_private: false,
          gender: '',
          website: '',
          birthday: '',
        }
      }
      
      // Create call object
      const call: Call = {
        id: data.call_id,
        call_type: data.call_type,
        conversation: data.conversation_id,
        caller: caller,
        status: 'ringing',
        offer_sdp: data.offer_sdp,
        answer_sdp: null,
        participants: [],
        duration: null,
        duration_display: '00:00',
        initiated_at: new Date().toISOString(),
        answered_at: null,
        ended_at: null,
      }
      
      console.log('âœ… Setting incoming call:', call)
      
      // âœ… If this is NOT the caller, show incoming call notification
      if (!data.is_caller) {
        setIncomingCall(call)
        dispatch(setCurrentCall(call))
        
        // Show browser notification if supported
        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification('Incoming Call', {
            body: `${data.caller_username} is calling...`,
            icon: '/call-icon.png'
          })
        }
        
        // Play ringtone
        const ringtone = new Audio('/ringtone.mp3')
        ringtone.loop = true
        ringtone.play().catch(e => console.error('Failed to play ringtone:', e))
      } else {
        // Caller sees "calling..." state
        dispatch(setCurrentCall(call))
      }
    })

    // Call answered
    const unsubAnswered = callWs.on('call_answered', async (data) => {
      console.log('âœ… Call answered:', data)
      
      // Stop ringtone
      const ringtone = document.querySelector('audio')
      if (ringtone) ringtone.pause()
      
      try {
        let answer: RTCSessionDescriptionInit
        try {
          answer = typeof data.answer_sdp === 'string' 
            ? JSON.parse(data.answer_sdp) 
            : data.answer_sdp
        } catch (e) {
          answer = {
            type: 'answer',
            sdp: data.answer_sdp
          }
        }
        
        console.log('âœ… Setting remote answer:', answer)
        await webrtc.setRemoteAnswer(answer)
        
        // Update call status
        if (currentCall) {
          dispatch(setCurrentCall({
            ...currentCall,
            status: 'answered',
            answered_at: new Date().toISOString()
          }))
        }
      } catch (error) {
        console.error('âŒ Failed to process answer:', error)
        toast({
          title: "Call failed",
          description: "Failed to establish connection",
          variant: "destructive"
        })
      }
    })

    // ICE candidate received
    const unsubIce = callWs.on('ice_candidate', async (data) => {
      console.log('ðŸ§Š ICE candidate received:', data)
      
      try {
        await webrtc.addIceCandidate(data.candidate)
      } catch (error) {
        console.error('âŒ Failed to add ICE candidate:', error)
      }
    })

    // Call ended
    const unsubEnded = callWs.on('call_ended', (data) => {
      console.log('ðŸ“´ Call ended:', data)
      webrtc.cleanup()
      dispatch(setCurrentCall(null))
      setIncomingCall(null)
      
      toast({
        title: "Call ended",
        description: `Call duration: ${data.duration}s`
      })
    })

    // Call rejected
    const unsubRejected = callWs.on('call_rejected', (data) => {
      console.log('âŒ Call rejected:', data)
      webrtc.cleanup()
      dispatch(setCurrentCall(null))
      setIncomingCall(null)
      
      toast({
        title: "Call rejected",
        description: "The call was declined"
      })
    })

    return () => {
      unsubIncoming()
      unsubAnswered()
      unsubIce()
      unsubEnded()
      unsubRejected()
    }
  }, [callWs, dispatch, webrtc, currentCall])
  
  // Initiate a call
  const startCall = useCallback(async (
    conversationId: string, 
    callType: 'audio' | 'video'
  ) => {
    try {
      console.log('ðŸ“ž Starting call...', { conversationId, callType })
      
      // 1. Create WebRTC offer
      const offer = await webrtc.createOffer(callType === 'video')
      console.log('âœ… Created offer:', offer)
      
      // 2. Send offer via WebSocket (this will create the call in backend)
      const offerString = JSON.stringify(offer)
      console.log('ðŸ“¤ Sending offer via WebSocket')
      callWs.initiateCall(conversationId, callType, offerString)
      
      toast({
        title: "Calling...",
        description: "Waiting for response"
      })
    } catch (error) {
      console.error('âŒ Failed to initiate call:', error)
      webrtc.cleanup()
      toast({
        title: "Call failed",
        description: "Failed to start call",
        variant: "destructive"
      })
      throw error
    }
  }, [callWs, webrtc])
  
  // Answer incoming call
  const acceptCall = useCallback(async (
    callId: string, 
    offerSdp: string,
    callType: 'audio' | 'video'
  ) => {
    try {
      console.log('âœ… Accepting call...', { callId, callType })
      
      let offer: RTCSessionDescriptionInit
      try {
        offer = typeof offerSdp === 'string' ? JSON.parse(offerSdp) : offerSdp
      } catch (e) {
        offer = {
          type: 'offer',
          sdp: offerSdp
        }
      }
      
      console.log('âœ… Parsed offer:', offer)
      
      if (!offer.type || !offer.sdp) {
        throw new Error('Invalid offer: missing type or sdp')
      }
      
      // Create WebRTC answer
      const answer = await webrtc.createAnswer(offer, callType === 'video')
      console.log('âœ… Created answer:', answer)
      
      // Send answer via WebSocket
      const answerString = JSON.stringify(answer)
      console.log('ðŸ“¤ Sending answer via WebSocket')
      callWs.answerCall(callId, answerString)
      
      // Clear incoming call
      setIncomingCall(null)
      
      toast({
        title: "Call connected",
        description: "You are now in a call"
      })
    } catch (error) {
      console.error('âŒ Failed to answer call:', error)
      webrtc.cleanup()
      toast({
        title: "Failed to answer",
        description: "Could not connect to the call",
        variant: "destructive"
      })
      throw error
    }
  }, [callWs, webrtc])
  
  // Reject call
  const rejectCall = useCallback((callId: string) => {
    console.log('âŒ Rejecting call:', callId)
    callWs.rejectCall(callId)
    dispatch(setCurrentCall(null))
    setIncomingCall(null)
    
    toast({
      title: "Call rejected",
      description: "You declined the call"
    })
  }, [callWs, dispatch])
  
  // End call
  const hangUp = useCallback(async (callId: string) => {
    console.log('ðŸ“´ Hanging up:', callId)
    
    webrtc.cleanup()
    callWs.endCall(callId)
    
    await dispatch(endCallAction(callId) as any)
    dispatch(setCurrentCall(null))
    setIncomingCall(null)
  }, [callWs, dispatch, webrtc])
  
  return {
    currentCall,
    incomingCall,
    connectionState: webrtc.connectionState,
    localStream: webrtc.localStream,
    remoteStream: webrtc.remoteStream,
    isLocalVideoEnabled: webrtc.isLocalVideoEnabled,
    isLocalAudioEnabled: webrtc.isLocalAudioEnabled,
    
    startCall,
    acceptCall,
    rejectCall,
    hangUp,
    toggleVideo: webrtc.toggleVideo,
    toggleAudio: webrtc.toggleAudio,
    switchCamera: webrtc.switchCamera,
  }
}